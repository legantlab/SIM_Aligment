% Script for predicting the correct axial misalignment
% Results are in r_id and c_id
%% Load unshifted OTF library
% path for the OTF library (generated with the script in GeneratePSFLibrary folder)
OTF_lib_path = 'V:\Yu\SIM_Alignment_Paper\DemoCode\DemoData\PSF_lib\OTF_library.mat';

load(OTF_lib_path);
n_phase = size(Olib,5);
n_level = size(Olib,4);

% foler for SIM data
folder = 'V:\Yu\SIM_Alignment_Paper\DemoCode\DemoData\SIM';

pxl_dim_PSF = [0.11,0.11,0.1072];     %pixel size of PSF in [x,y,z]
pxl_dim_data = [0.11,0.11,0.2*sind(32.5)];    %pixel size of data in [x,y,z]

lattice_period = 1.214; %Lattice period in microns - this is the coarsest period
lattice_angle = [pi/2]; %Angle parellel to pattern modulation (assuming horizontal is zero)
phase_step = .2428; %Phase step in microns

NA_det=1.0; % NA of detection objective
nimm=1.33; % refractive index of imaging media
NA_ext_max=0.55; % Maximum NA of excitation pattern
wvl_em=.605;   % wavelength of emission
wvl_ext=.560;   % wavelength of excitation

alpha_det=asin(NA_det/nimm); %Half angle for detection NA
alpha_ext=asin(NA_ext_max/nimm); %Half angle for excitation NA
kmag_det=nimm/wvl_em; %k-vector magnitude for detection
kmag_ext=nimm/wvl_ext; %k-vector magnitude for excitation


%% Estimate shifting P vector
   
p_vec_guess=zeros(5,3);

for kk=1:floor(n_level/2) %Only consider negative orders
    order=(kk-ceil(n_level/2)); %m'th order information component
    k_shift_scaling = 1/lattice_period; %Convert pattern frequency into k-space pixel units
    
    %Estimated shift vector
    p_vec_guess(kk,:)=-order*k_shift_scaling.*[cos(lattice_angle),sin(lattice_angle),0];
end

%% read sample data

phase_dist = zeros(n_phase,n_phase);

Samplestr = dir([folder '\' 'ds_crop*.tif']);    %ds_Raw_img_cropped

for ifile = 1:length(Samplestr)
Sample_filename = strcat(Samplestr(ifile).folder,'\',Samplestr(ifile).name);
OTF_stack_image = seperate_sample(Sample_filename,n_level);
[ny_data,nx_data,nz_data,~]=size(OTF_stack_image);

data_dim = [ny_data,nx_data,nz_data];

OTF_shift_image_stack = zeros([size(OTF_stack_image,1:3) (n_level+1)/2]);
OTF_shift_singlebead_stack = zeros([size(OTF_stack_image,1:3) (n_level+1)/2]);


%% build up mask of the overlap region between different lateral components

dk_data=1./([nx_data,ny_data,nz_data].*pxl_dim_data);
%Set up vectors based on data image size
kxxdata=[-ceil((nx_data-1)/2):floor((nx_data-1)/2)]*dk_data(1);
kyydata=[-ceil((ny_data-1)/2):floor((ny_data-1)/2)]*dk_data(2);
kzzdata=[-ceil((nz_data-1)/2):floor((nz_data-1)/2)]*dk_data(3);

%Set up arrays for data frequency space pixels
[kxxdata_arr,kyydata_arr,kzzdata_arr]=meshgrid(kxxdata,kyydata,kzzdata);

% Calculate the axial and radial size of cylinder mask
radial_extent=(2*NA_det/wvl_em);
axial_extent=kmag_ext*sin(alpha_ext)+kmag_det*(1-cos(alpha_det));
axial_extent_inner = kmag_ext*sin(alpha_ext)-0.5*kmag_det*(1-cos(alpha_det));
axial_extent_outer = kmag_ext*sin(alpha_ext)+0.5*kmag_det*(1-cos(alpha_det));

cylmask_0=(sqrt(kxxdata_arr.^2+kyydata_arr.^2)<=radial_extent)&(sqrt(kzzdata_arr.^2)<=axial_extent);
cylmask_1=(sqrt((kxxdata_arr-p_vec_guess(2,1)).^2+(kyydata_arr-p_vec_guess(2,2)).^2)<=(radial_extent))&(sqrt(kzzdata_arr.^2)<=axial_extent);
cylmask_2=(sqrt((kxxdata_arr-p_vec_guess(1,1)).^2+(kyydata_arr-p_vec_guess(1,2)).^2)<=(radial_extent))&(sqrt(kzzdata_arr.^2)<=axial_extent);

overlap_mask = true(ny_data,nx_data,nz_data,3);
overlap_mask(:,:,:,1) = and(cylmask_0,cylmask_1);
overlap_mask(:,:,:,2) = and(cylmask_0,cylmask_2);
overlap_mask(:,:,:,3) = and(cylmask_1,cylmask_2);

%% shift Sample data OTF based on guessed P vector
    for i =1:(n_level+1)/2
        OTF_shift_image_stack(:,:,:,i) = ifourierShift3D(OTF_stack_image(:,:,:,i),p_vec_guess(i,:).*([nx_data,ny_data,nz_data].*pxl_dim_data));
    end

%% Loop over files with different axial phase shift

for j = 1:n_phase
    %% Read OTF at different level from file generated by makeOTF bat file
    
    
    OTF_singlebead_stack = rescale_OTF(squeeze(Olib(:,:,:,:,j)),pxl_dim_PSF,data_dim,pxl_dim_data);
    
    for i =1:(n_level+1)/2       
        OTF_shift_singlebead_stack(:,:,:,i) = ifourierShift3D(OTF_singlebead_stack(:,:,:,i),p_vec_guess(i,:).*([nx_data,ny_data,nz_data].*pxl_dim_data));                    
    end
    
    
    %% calculate residual phase in overlap regions

    % calculate Dm1Om2 
    D1O0 = squeeze(OTF_shift_image_stack(:,:,:,2)).*squeeze(OTF_shift_singlebead_stack(:,:,:,3));
    D0O1 = squeeze(OTF_shift_image_stack(:,:,:,3)).*squeeze(OTF_shift_singlebead_stack(:,:,:,2));
    
    D2O0 = squeeze(OTF_shift_image_stack(:,:,:,1)).*squeeze(OTF_shift_singlebead_stack(:,:,:,3));
    D0O2 = squeeze(OTF_shift_image_stack(:,:,:,3)).*squeeze(OTF_shift_singlebead_stack(:,:,:,1));
    
    D2O1 = squeeze(OTF_shift_image_stack(:,:,:,1)).*squeeze(OTF_shift_singlebead_stack(:,:,:,2));
    D1O2 = squeeze(OTF_shift_image_stack(:,:,:,2)).*squeeze(OTF_shift_singlebead_stack(:,:,:,1));  


    %Calculate Rm1m2
    O0O1_ratio_temp = D1O0./D0O1;
    O0O2_ratio_temp = D2O0./D0O2;
    O1O2_ratio_temp = D2O1./D1O2;   
    
    % filter Rm1m2 in with overlap masks 
    O0O1_ratio_mask = log(sqrt(abs(D1O0).*abs(D0O1)));
    O0O2_ratio_mask = log(sqrt(abs(D2O0).*abs(D0O2)));
    O1O2_ratio_mask = log(sqrt(abs(D1O2).*abs(D2O1)));      
    
    O0O1_ratio_temp(~overlap_mask(:,:,:,1))=nan;
    O1O2_ratio_temp(~overlap_mask(:,:,:,3))=nan;   
    O0O1_ratio_mask(~overlap_mask(:,:,:,1))=nan;
    O1O2_ratio_mask(~overlap_mask(:,:,:,3))=nan;   
    
    ratio_vec_temp = cat(3,O0O1_ratio_temp,O1O2_ratio_temp); 
    ratio_vec_mask = cat(3,O0O1_ratio_mask,O1O2_ratio_mask); 


    % shift laterally to create 2D phase map
    for k = 1:n_phase
        B_ratio = exp(1i*(-pi + (k-1)*pi/((n_phase-1)/2)));
        ratio_vec_temp_LateralShift = ratio_vec_temp/B_ratio;
        phase_dist(j,k) = sum(abs(angle(mean(ratio_vec_temp_LateralShift.*ratio_vec_mask,[1 2],'omitnan'))),'omitnan');
    end
        
end

%% fitting minimum of 2D phase map

crop_range = 10;
phase_dist_crop = phase_dist(:,(n_phase+1)/2-crop_range:(n_phase+1)/2+crop_range);
[min_val,min_coord] = min(phase_dist_crop(:));
[r_id,c_id]=ind2sub(size(phase_dist_crop),min_coord);
c_id = c_id+(n_phase+1)/2-crop_range;
winsize = 7;
[r_id_primary,c_id_primary] = fit_2D_phasemap(phase_dist,r_id,c_id,winsize);

r_id = r_id_primary;  % minimum row index
c_id = c_id_primary;  % minimum column index

save([Sample_filename(1:end-4) '.mat'],'phase_dist','r_id','c_id','n_phase');
%% calculate euladician distances
figure
imagesc(phase_dist);
axis equal;
xlim([0 n_phase]);
xlabel('lateral phase');
ylim([0 n_phase]);
ylabel('axial phase');
colorbar;
title (['min: axial ' num2str(r_id) ',  lateral ' num2str(c_id)]);

end

